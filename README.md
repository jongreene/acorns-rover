<img src="https://i1380.photobucket.com/albums/ah174/nibbleoverbyte/6db4ab84-d0be-4a54-b1a0-f3dc903e4d98_zpspbunmdpz.jpeg" width="250" title="Rover on foam pad"></img>
# Semi-Autonomous Rover
> This highly configurable, bluetooth enabled rover, is controlled by a Giant Gecko STK3700 development board. Currently, the board is configured to drive four independently timed pwm motor-drivers, handle bi-directional UART communication, and sample external sensor data from custom PCBs or a shared i2c bus.

## Initial setup
### Cloning
> To clone this project, open a terminal where you want the repository to reside. Then enter git clone https://github.com/jongreene/semi-autonomous-rover.git and hit return.
### Compiling
> In order to compile, you must first create a folder in the root of the directory called "RELEASE" (for the time being). </br>Open a terminal and cd into that directory.
</br>Now issue the command: ?>cmake ..
</br>
#### Resolving dependencies
> At runtime, the cmake build system will automatically download a local copy of the ARM GNU toolchain as well as Mbed OS. The downloaded toolchain will be linked and configured to be used when compiling. The downloaded copy of Mbed OS will be switched to the version defined in the root CMakeLists.txt. Once all of the resources have been downloaded, any and all relavent patches are then applied to the third-party resources.


### Flashing the STK3700

## Commands
### Command format
> {command_name,param1,param2,...}
### Example command
> {drive,40,40,20,20}
### Command responses
> There are two types of responses that can be expected when issuing a command. The first is an acknowledgement that a line (\n) of data was received, and whether or not that data was properly formatted and requesting a valid function. The second type of response is generated by the function being invoked and can happen as many times as desired, so long as the function is still executing.

### Creating new commands
> Through the use of a highly modularized C/C++ framework, defining new callable functions takes little to no understanding of the underlying services. New routines can be implemented in just a few steps, making driver development fast and simple. While this rover is very capable, the underlying framework that drives it is the true bread and butter of this project.

### Communication
...

#### UART handling
...

## Device drivers
...

