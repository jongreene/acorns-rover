<img src="https://i1380.photobucket.com/albums/ah174/nibbleoverbyte/6db4ab84-d0be-4a54-b1a0-f3dc903e4d98_zpspbunmdpz.jpeg" width="250" title="Rover on foam pad"></img>
# Semi-Autonomous Rover
> This highly configurable, bluetooth enabled rover, is controlled by a Giant Gecko STK3700 development board. Currently, the board is configured to drive four independently timed pwm motor-drivers, handle bi-directional UART communication, and sample external sensor data from custom PCBs or a shared i2c bus.

### Initial setup
##### Cloning
> To clone this project, open a terminal where you want the repository to reside. Then enter git clone https://github.com/jongreene/semi-autonomous-rover.git and hit return.
##### Dependencies
> At runtime, the cmake build system will automatically download a local copy of the ARM GNU toolchain as well as Mbed OS. The downloaded toolchain will be linked and configured to be used when compiling. The downloaded copy of Mbed OS will be switched to the version defined in the root CMakeLists.txt. Once all of the resources have been downloaded, any and all relavent patches are then applied to the third-party resources.
##### Compiling
> In order to compile, you must first create a folder in the root of the directory called "RELEASE" (for the time being). </br>Open a terminal and cd into that directory.
</br>Now issue the command: ?>cmake ..
</br>Wait for CMake to complete generating the build files.
</br>Now issue the command: ?>make
##### Flashing the STK3700
> I will be using a standalone J-Link JTAG/SWD programmer to flash the resulting binary onto the board. It is possible (and likely easier) to flash the development board using the built in J-Link programmer however I will likely develop my own board and want the methods I use to transfer over. 
## Communicating with the rover
### Setting up UART
> The rover is currently configured to send and receive data at 9600 baud.
### Command overview
##### Command format
> {command_name,param1,param2,...}
##### Example command
> {drive,40,40,20,20}
##### Command responses
> There are two types of responses that can be expected when issuing a command. The first is an acknowledgement that a line (\n) of data was received, and whether or not that data was properly formatted and requesting a valid function. The second type of response is generated by the function being invoked and can happen as many times as desired, so long as the function is still executing.
##### Command error responses

<ul>
  <li>bad json: {"nak":"","payload":{"return_value":false,"return_string":"json error: badly formatted json"}}</li>
  <li>command not found: {"notification":"payload":{"return_string":"error: command not found"}}</li>
  <li>command running: {"notification":"payload":{"return_string":"error: command is already running"}}</li>
  <li>command stopped: {"notification":"payload":{"return_string":"error: command is not running"}}</li>
  <li>queue overflowed: {"notification":"payload":{"return_string":"error: queue overflowed"}}</li>
</ul> 

### Creating new commands

> Through the use of a highly modularized C/C++ framework, defining new callable functions takes little to no understanding of the underlying services. New routines can be implemented in just a few steps, making driver development fast and simple. While this rover is very capable, the underlying framework that drives it is the true bread and butter of this project.
