# Semi-Autonomous Rover (under construction)
This highly configurable, bluetooth enabled rover, is controlled by a Giant Gecko STK3700 development board. Currently, the board is configured to drive four independently timed pwm motor-drivers, handle bi-directional UART communication, and sample external sensor data from custom PCBs or a shared i2c bus.

<img src="https://i1380.photobucket.com/albums/ah174/nibbleoverbyte/6db4ab84-d0be-4a54-b1a0-f3dc903e4d98_zpspbunmdpz.jpeg" width="250" title="Rover on foam pad"></img>

Setup
---
Following this guide should be fairly straight forward as long as you have the following tools installed:
- [CMake](https://cmake.org/download/) 
- [J-Link Software](https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack)
##### Cloning
Open a terminal and navigate to where you want the repository to reside. From the terminal enter the command below.
```bash 
  # clone the repository
  $ git clone https://github.com/jongreene/semi-autonomous-rover.git
```

##### Compiling
Before compiling, you must prepare the project. From the root of the repository open a terminal and enter the commands below.
```bash
  # create a RELEASE directory
  $ mkdir RELEASE

  # enter that directory
  $ cd RELEASE
```
Next we'll generate build files. 
> The first time you run cmake it will take substantially longer. This is due to the cmake build system automatically downloading local copies of the ARM GNU toolchain as well as Mbed OS. The third-party resources are then patched. 
From the RELEASE directory, enter the commands below.
```bash
  # resolve dependencies and generate build files
  $ cmake ..

  # compile STK3700 binary
  $ make
```

##### Flashing
> I will be using a standalone J-Link JTAG/SWD programmer to flash the resulting binary onto the board.

From a terminal pointed at the build directory, enter the commands below.
```bash
  # connect to board
  $ JLinkExe -device EFM32GG380F1024 -if SWD -speed 4000

  # load the binary onto the STK3700
  $ loadbin bin/semi-autonomous-rover.bin, 0x0

  # reset and start the board
  $ r
  $ g
```

The board should now be running the new binary.

Communication
---
The rover is setup to work seamlessly with [this](https://www.adafruit.com/product/2479) bluetooth module but will work with any standard UART device.

##### UART setup
Below you will find images that will guide you in setting up a USB UART connection with CuteCom

> Connection of a UART-to-USB adapter to the board.

> CuteCom using the rover's default baud rate.

##### Command format
```bash
  input: {command_name,param1,param2,...}\n 
```
> The newline character `\n` is shown only for clarity but should be generated by your UART client.

##### Example command
```bash
  input: {drive,40,40,20,20}
```

##### Command responses
There are two types of responses that can be expected when issuing a command. 
- An acknowledgement that a line (\n) of data was received, and whether or not that data was properly formatted and requesting a valid function. 
- A response generated by the function being invoked and can happen as many times as desired, so long as the function is still executing.

##### Command error responses
- bad json: {"nak":"","payload":{"return_value":false,"return_string":"json error: badly formatted json"}}
- command not found: {"notification":"payload":{"return_string":"error: command not found"}}
- command running: {"notification":"payload":{"return_string":"error: command is already running"}}
- command stopped: {"notification":"payload":{"return_string":"error: command is not running"}}
- queue overflowed: {"notification":"payload":{"return_string":"error: queue overflowed"}}

Customization
---
This project is open source, so customization is absoultely possible and encouraged. The easiest place to start is by creating some custom commands and calling them over UART. You'll find that it's surprisingly easy to add new functionality, once you have your development environment configured.
##### Creating commands
> Through the use of a highly modularized C/C++ framework, defining new callable functions takes little to no understanding of the underlying services. New routines can be implemented in just a few steps, making driver development fast and simple. While this rover is very capable, the underlying framework that drives it is the true bread and butter of this project.
